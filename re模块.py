import re

#match()方法判断是否匹配，如果匹配成功，返回一个Match对象，
#否则返回None
m1 = re.match(r'^\d{3}\-\d{3,8}$', '010-12345')
print('匹配成功则返回：',m1)
m2 = re.match(r'^\d{3}\-\d{3,8}$', '010 12345')
print('匹配失败则返回：',m2)
print('++++++++++++++++++++++++++++++++')

#还可以用来切分字符串
#先看下正常的切分代码：
s1 = 'a b   c'.split(' ')
print('正常切分：',s1)#无法识别连续的空格

#用正则表达式切分：
s2 = re.split(r'\s+','a b   c')#注意书写方式的不同
print('正则表达式切分',s2)

#加入','试试:
s3 = re.split(r'[\s\,]+','a,b, c  d')
print("加入，切分：",s3)

#再加入';'试试：
s4 = re.split(r'[\s\,\:]+','a,b:: c  d')
print("加入；切分：",s4)

print('++++++++++++++++++++++++++++++++++++')

#除了简单地判断是否匹配之外，正则表达式还有提取子串的功能
#用()表示的就是要提取的分组（Group）
#比如^(\d{3})-(\d{3,8})$分别定义了两个组，
#可以直接从匹配的字符串中提取出区号和本地号码：
import re
m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
print('match对象:',m)

#如果在正则表达式中定义了组，就可以用group()方法从match中提取出子串：
print('m.group(0):',m.group(0))#group(0)永远是原始字符
print('m.group(1):',m.group(1))#group(1)表示第一个子串
print('m.group(2):',m.group(2))#group(2)表示第二个子串

print('+++++++++++++++++++++++++++++++++++++++++++')
#识别合法的时间
t = '19:05:30'
m = re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2\
		[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]\
		|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$', t)
print(m.groups(),m.group())

print('+++++++++++++++++++++++++++++++++++++++++++')
#贪婪匹配
#正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符，举例如下，匹配出数字后的0：
p1 = re.match(r'^(\d+)(0*)$','102300').groups()
print('贪婪匹配：',p1)
#犹豫\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了

#若要把后面的0匹配出来，加个？就可以让\d+采用非贪婪匹配
p2 = re.match(r'^(\d+?)(0*)$', '102300').groups()
print('非贪婪匹配：',p2)

print('+++++++++++++++++++++++++++++++++++++')
#编译
#当我们在python中使用正则表达式时，re模块内部会干两件事情：
#1.编译正则表达式，如果表达式的字符串本身不合法，会报错；
#2.用编译后的正则表达式去匹配字符串
#如果一个正则表达式要重复使用几千次，处于效率考虑，可以预编译该正则表达式，
#接下来重复使用时就不需要编译这个步骤了，直接匹配。

#编译：
re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
#使用：
y1 = re_telephone.match('010-12345').groups()

y2 = re_telephone.match('010-8086').groups()
print(y1)
print(y2)
